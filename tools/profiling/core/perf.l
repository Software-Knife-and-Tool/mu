(mu:intern mu:*null/* "core-perf"
   (:lambda ()
     (core:compile '(%lambda ()))
     (core:compile '(%lambda (a) a))
     (core:compile '(%lambda (&rest c)))
     (core:compile '(%lambda (a b) (mu:add a b)))
     (core:compile '(%lambda (a b &rest c) (mu:add a b) c))
     (mu:eval (core:compile '((%lambda (a) (%if a a)) 1)))
     (core:eval '(%defmacro foo ()))
     (core:eval '(%if :t :t :t))
     (core:eval '(%if :t :t))
     (core:eval '(%if :t (mu:add 0 1) (mu:add 0 0)))
     (core:eval '(%if (core:null ()) (mu:add 0 1) (mu:add 0 0)))
     (core:eval '(%if (core:null (core:null :t)) (mu:add 0 1) (mu:add 0 0)))
     (mu:eval (core:compile '(core:append)))
     (mu:eval (core:compile '(core:append '(1 2 3) 4)))
     (mu:eval (core:compile '(core:append '(1 2 3) '(4))))
     (mu:eval (core:compile '(core:list)))
     (mu:eval (core:compile '(core:list 1)))
     (mu:eval (core:compile '(core:list 1 2 3)))
     (mu:eval (core:compile '(core:list*)))
     (mu:eval (core:compile '(core:list* 1)))
     (mu:eval (core:compile '(core:list* 1 2 3)))
     (mu:eval (core:compile '(core:let ())))
     (mu:eval (core:compile '(core:let () 1)))
     (mu:eval (core:compile '(core:let () 1 2)))
     (mu:eval (core:compile '(core:let ((a 0)) a)))
     (mu:eval (core:compile '(core:let ((a 1) (b 2)) (mu:add a b))))
     (mu:eval (core:compile '(core:let* ())))
     (mu:eval (core:compile '(core:let* () 1)))
     (mu:eval (core:compile '(core:let* () 1 2)))
     (mu:eval (core:compile '(progn)))
     (mu:eval (core:compile '(progn 1)))
     (mu:eval (core:compile '(progn 1 2)))
     (mu:eval (core:compile '(when :t ())))
     (mu:eval (core:compile '(when :t 1)))
     (mu:eval (core:compile '(when :t 1 2)))
     (mu:eval (core:compile '(when () ())))
     (mu:eval (core:compile '(when () 1)))
     (mu:eval (core:compile '(when () 1 2)))
     (mu:eval (core:compile '(unless :t ())))
     (mu:eval (core:compile '(unless :t 1)))
     (mu:eval (core:compile '(unless :t 1 2)))
     (mu:eval (core:compile '(unless () ())))
     (mu:eval (core:compile '(unless () 1)))
     (mu:eval (core:compile '(unless () 1 2)))
     (mu:eval (core:compile '(and)))
     (mu:eval (core:compile '(and 1)))
     (mu:eval (core:compile '(and 1 2)))
     (mu:eval (core:compile '(or)))
     (mu:eval (core:compile '(or 1)))
     (mu:eval (core:compile '(or 1 2)))
     (mu:eval (core:compile '(cond)))
     (mu:eval (core:compile '(cond (1 'a))))
     (mu:eval (core:compile '(cond (() 'a) (1 'b 'c))))
     (core:structp (core:%make-exception () :error 'test "exception test" ()))
     (core:exceptionp (core:%make-exception () :error 'test "exception test" ()))
     (core:with-exception (:lambda (ex) :t) (:lambda () (core:raise () 'test "")))
     (core:with-exception (:lambda (exception) ()) (:lambda () :t))
     (core:stringp (core:%format () "core:%format" ()))
     (core:%format () "core:%format unqualified ~A symbol arg" '(f-symbol))
     (core:%format () "core:%format qualified ~A symbol arg" '(mu:add))
     (core:%format () "core:%format ~A string arg" '("f-string"))
     (core:%format () "core:%format ~X fixnum arg" '(#xabcddcba))
     (core:apply (core:compile '(%lambda () 1)) ())
     (core:apply (core:compile '(%lambda (a b) (core:null b))) '(1 2))
     (core:apply (core:compile '(%lambda (a b) (mu:add 1 2))) '(1 2))
     (core:apply (core:compile '(%lambda (a b) (mu:add a b))) '(1 2))
     (core:apply (core:compile '(%lambda (a b) (mu:type-of b))) '(1 2))
     (core:apply (core:compile '(%lambda (a) a)) '(1))
     (core:apply (core:compile '(%lambda (a b) 1)) '(2 3))
     (core:apply (core:compile '(%lambda (a b) (core:fixnump b))) '(1 2))
     (core:apply (core:compile '(%lambda (a b) (mu:add a b))) '(1 2))
     (core:apply (core:compile '(%lambda (&rest e) e)) '(1 2 3 4 5))
     (core:apply (core:compile '(%lambda (a &rest e) e)) '(1 2 3 4 5))
     (core:apply (core:compile '(%lambda (a b &rest e) e)) '(1 2 3 4 5))
     (core:apply (core:compile '(%lambda (a b c &rest e) e)) '(1 2 3 4 5))
     (core:apply (core:compile '(%lambda (a b c d &rest e) e)) '(1 2 3 4 5))
     (core:apply (core:compile '(%lambda (a b c d e &rest f) f)) '(1 2 3 4 5))
     (mu:type-of (core:apply (core:compile '(%lambda (a) (mu:apply a ()))) (mu:cons (:lambda () 1) ())))
     (core:apply (core:compile '(%lambda (a &rest b) (mu:cons a b))) (mu:cons (mu:car '(1 2 3)) ()))
     (core:apply (core:compile '(%lambda (a &rest b) (mu:cons a b))) (mu:cons (mu:car `(,(mu:add 2 1) 2 1)) ()))
     (mu:type-of core:%reverse)
     (core:%append '(() ()))
     (core:%append '(() (1 2 3)))
     (core:%append '((1 2 3) (4 5 6)))
     (core:%append '((1 2) 3))
     (core:%dropl '(1 2 3) 1)
     (core:%dropr '(1 2 3) 1)
     (core:%find-if core:symbolp '(1 2 3))
     (core:%find-if core:symbolp '(a b c))
     (core:%foldl (:lambda (el acc) (:if (core:null acc) :nil (core:symbolp el))) :t '(1 2 3))
     (core:%foldl (:lambda (el acc) (:if (core:null acc) :nil (core:symbolp el))) :t '(a b c))
     (core:%foldl (:lambda (el acc) (mu:cons el acc)) () '(1 2 3 4))
     (core:%foldl (:lambda (el acc) (mu:cons el acc)) () '(1))
     (core:%foldl (:lambda (el acc) (mu:cons el acc)) () ())
     (core:%foldl (:lambda (x y) (mu:add x y)) 0 '(1 2 3))
     (core:%foldr (:lambda (el acc) (:if (core:null acc) :nil (core:symbolp el))) :t '(1 2 3))
     (core:%foldr (:lambda (el acc) (:if (core:null acc) :nil (core:symbolp el))) :t '(a b c))
     (core:%foldr (:lambda (el acc) (mu:cons el acc)) () '(1 2 3 4))
     (core:%foldr (:lambda (el acc) (mu:cons el acc)) () '(1))
     (core:%foldr (:lambda (el acc) (mu:cons el acc)) () ())
     (core:%foldr (:lambda (x y) (mu:add x y)) 0 '(1 2 3))
     (core:%mapc (:lambda (el) el) '(1 2 3))
     (core:%mapc (:lambda (el) el) ())
     (core:%mapcar (:lambda (el) el) '(1 2 3))
     (core:%mapcar (:lambda (el) el) ())
     (core:%mapl (:lambda (el) el) '(1 2 3))
     (core:%mapl (:lambda (el) el) ())
     (core:%maplist (:lambda (el) el) '(1 2 3))
     (core:%maplist (:lambda (el) el) ())
     (core:%position-if (:lambda (el) (mu:eq el 'foo)) '(foo))
     (core:%position-if (:lambda (el) (mu:eq el 'foo)) '(1 foo))
     (core:%reverse '(1 2 3 4))
     (mu:cdr (core:%assq #\a '((#\a . foo))))
     (mu:cdr (core:%assq #\a '(() (#\a . foo))))
     (mu:type-of ((:lambda () (core:compile '(%defmacro a-macro () a-macro)) (core:macro-function 'a-macro ()))))
     ((:lambda () (core:compile '(%defmacro no-arg-macro () ''no-arg-macro)) (core:macroexpand '(no-arg-macro) ())))
     ((:lambda () (core:compile '(%defmacro no-arg-macro () ''no-arg-macro)) (mu:eval (core:compile '(no-arg-macro)))))
     ((:lambda () (core:compile '(%defmacro arg-macro (arg) arg)) (core:macroexpand '(arg-macro (mu:add 1 2)) ())))
     ((:lambda () (core:compile '(%defmacro arg-macro (arg) arg)) (mu:eval (core:compile '(arg-macro (mu:add 1 2))))))
     ((:lambda () (core:compile '(%defmacro rest-macro (&rest args) (mu:car args))) (mu:eval (core:compile '(rest-macro (mu:add 1 2))))))
     ((:lambda () (core:compile '(%defmacro rest-macro (a &rest b)  (mu:cons :quote (mu:cons a b)))) (mu:eval (core:compile '(rest-macro 1 2)))))
     ((:lambda () (core:compile '(%defmacro rest-macro (a &rest b)  (mu:cons :quote (mu:cons a b)))) (mu:eval (core:compile '(rest-macro 1 (core:1+ 1))))))
     (mu:symbol-name (core:read (mu:open :string :input "a" :t) () ()))
     (mu:symbol-name (core:read (mu:open :string :input "core:a" :t) () ()))
     (core:read (mu:open :string :input "abcdefgh" :t) () ())
     (core:read (mu:open :string :input "core:abcdefgh" :t) () ())
     (core:read (mu:open :string :input "'abcdefgh" :t) () ())
     (core:read (mu:open :string :input "'core:abcdefgh" :t) () ())
     (core:read (mu:open :string :input "1024" :t) () ())
     (core:read (mu:open :string :input "-1024" :t) () ())
     (core:read (mu:open :string :input "1.024" :t) () ())
     (core:read (mu:open :string :input "#b10101100" :t) () ())
     (core:read (mu:open :string :input "#d1024" :t) () ())
     (core:read (mu:open :string :input "#xabcdef" :t) () ())
     (core:read (mu:open :string :input "(())" :t) () ())
     (core:read (mu:open :string :input "(a b)" :t) () ())
     (core:read (mu:open :string :input "(:a :b)" :t) () ())
     (core:read (mu:open :string :input "(:abc ())" :t) () ())
     (core:read (mu:open :string :input "(1 . 2)" :t) () ())
     (core:read (mu:open :string :input "(1 2 . 3)" :t) () ())
     (core:read (mu:open :string :input "((1 2) . 3)" :t) () ())
     (core:read (mu:open :string :input "((1 2) . (3 4q))" :t) () ())
     (mu:write 1000 () (mu:open :string :output "" :t))
     (mu:write (mu:mul 100 200) () (mu:open :string :output "" :t))
     (core:stringp "abc")
     (core:fixnump 5)
     (core:consp '(1 . 2))
     (core:fixnump 1)
     (core:floatp 1.0)
     (core:functionp core:functionp)
     (core:listp ())
     (core:null '())
     (core:streamp mu:*standard-input*)
     (core:stringp "abc")
     (core:symbolp 'core)
     (core:vectorp #(:t 1 2 3))
     (core:make-vector '(1 2 3))
     (core:%typep (core:make-vector '(1 2 3)))
     (core:vector-slice (core:make-vector '(1 2 3)) 1 2)
     (core:vector-length (core:make-vector '(1 2 3)))
     (core:vector-ref (core:make-vector '(1 2 3)) 1)
     (core:vectorp (core:make-vector '(1 2 3)))
     (core:vectorp (mu:make-vector :t '(1 2 3)))
))
