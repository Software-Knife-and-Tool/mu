(mu:intern mu:%null-ns% "core-perf"
   (:lambda ()
     (core:compile '(lambda))
     (core:compile '(lambda (a) a))
     (core:compile '(lambda (&rest c))))
     (core:compile '((lambda (a b) (mu:add a b)) 1 2))
     (core:compile '((lambda (a b &rest c) (mu:add a b) c) 1 2))
     (core:compile '(defconst foo ()))
     (core:compile '(if :t :t :t))
     (core:compile '(if :t :t))
     (core:compile '(if :t (mu:add 0 1) (mu:add 0 0)))
     (core:compile '(if (core:null ()) (mu:add 0 1) (mu:add 0 0)))
     (core:compile '(if (core:null (core:null :t)) (mu:add 0 1) (mu:add 0 0)))
     (core:%fixnump 5)
     (core:%consp '(1 . 2))
     (core:%fixnump 1)
     (core:%floatp 1.0)
     (core:functionp core:functionp)
     (core:listp ())
     (core:null :t)
     (core:null '())
     (core:%streamp mu:*standard-input*)
     (core:stringp "abc")
     (core:%symbolp 'core)
     (core:vectorp #(:t 1 2 3))
     (core:%structp (core:make-exception () :error 'test "exception test" ()))
     (core:exceptionp (core:make-exception () :error 'test "exception test" ()))
     (core:with-exception (:lambda (ex) :t) (:lambda () (core:raise () (:quote test) "")))
     (core:with-exception (:lambda (exception) ()) (:lambda () :t))
     (core:stringp (core:format () "core:format" ()))
     (core:format () "core:format unqualified ~A symbol arg" '(f-symbol))
     (core:format () "core:format qualified ~A symbol arg" '(mu:add))
     (core:format () "core:format ~A string arg" '("f-string"))
     (core:format () "core:format ~X fixnum arg" '(#xabcddcba))
     (mu:apply (core:compile '(lambda () 1)) ())
     (mu:apply (core:compile '(lambda (a b) (core:null b))) '(1 2))
     (mu:apply (core:compile '(lambda (a b) (mu:add 1 2))) '(1 2))
     (mu:apply (core:compile '(lambda (a b) (mu:add a b))) '(1 2))
     (mu:apply (core:compile '(lambda (a b) (mu:type-of b))) '(1 2))
     (core:apply (core:compile '(lambda (a) a)) '(1))
     (core:apply (core:compile '(lambda (a b) 1)) '(2 3))
     (core:apply (core:compile '(lambda (a b) (core:%fixnump b))) '(1 2))
     (core:apply (core:compile '(lambda (a b) (mu:add a b))) '(1 2))
     (core:apply (core:compile '(lambda (&rest e) e)) '(1 2 3 4 5))
     (core:apply (core:compile '(lambda (a &rest e) e)) '(1 2 3 4 5))
     (core:apply (core:compile '(lambda (a b &rest e) e)) '(1 2 3 4 5))
     (core:apply (core:compile '(lambda (a b c &rest e) e)) '(1 2 3 4 5))
     (core:apply (core:compile '(lambda (a b c d &rest e) e)) '(1 2 3 4 5))
     (core:apply (core:compile '(lambda (a b c d e &rest f) f)) '(1 2 3 4 5))
     (mu:type-of (core:apply (core:compile '(lambda (a) (a))) (mu:cons (:lambda () 1) ())))
     (mu:eval (core:compile '((lambda (a &rest b) (a b)) mu:car 1 2 3)))
     (mu:eval (core:compile '((lambda (a &rest b) (a b)) mu:car (mu:add 2 1) 2 1)))
     (mu:type-of core:%reverse)
     (core:%append '(() ()))
     (core:%append '(() (1 2 3)))
     (core:%append '((1 2 3) (4 5 6)))
     (core:%append '((1 2) 3))
     (core:%dropl '(1 2 3) 1)
     (core:%dropr '(1 2 3) 1)
     (core:%findl-if core:%symbolp '(1 2 3))
     (core:%findl-if core:%symbolp '(a b c))
     (core:%foldl (:lambda (el acc) (:if (core:null acc) :nil (core:%symbolp el))) :t '(1 2 3))
     (core:%foldl (:lambda (el acc) (:if (core:null acc) :nil (core:%symbolp el))) :t '(a b c))
     (core:%foldl (:lambda (el acc) (mu:cons el acc)) () '(1 2 3 4))
     (core:%foldl (:lambda (el acc) (mu:cons el acc)) () '(1))
     (core:%foldl (:lambda (el acc) (mu:cons el acc)) () ())
     (core:%foldl (:lambda (x y) (mu:add x y)) 0 '(1 2 3))
     (core:%foldr (:lambda (el acc) (:if (core:null acc) :nil (core:%symbolp el))) :t '(1 2 3))
     (core:%foldr (:lambda (el acc) (:if (core:null acc) :nil (core:%symbolp el))) :t '(a b c))
     (core:%foldr (:lambda (el acc) (mu:cons el acc)) () '(1 2 3 4))
     (core:%foldr (:lambda (el acc) (mu:cons el acc)) () '(1))
     (core:%foldr (:lambda (el acc) (mu:cons el acc)) () ())
     (core:%foldr (:lambda (x y) (mu:add x y)) 0 '(1 2 3))
     (core:%mapc (:lambda (el) el) '(1 2 3))
     (core:%mapc (:lambda (el) el) ())
     (core:%mapcar (:lambda (el) el) '(1 2 3))
     (core:%mapcar (:lambda (el) el) ())
     (core:%mapl (:lambda (el) el) '(1 2 3))
     (core:%mapl (:lambda (el) el) ())
     (core:%maplist (:lambda (el) el) '(1 2 3))
     (core:%maplist (:lambda (el) el) ())
     (core:%positionl-if (:lambda (el) (mu:eq el 'foo)) '(foo))
     (core:%positionl-if (:lambda (el) (mu:eq el 'foo)) '(1 foo))
     (core:%reverse '(1 2 3 4))
     (mu:cdr (core:%assq #\a '((#\a . foo))))
     (mu:cdr (core:%assq #\a '(() (#\a . foo))))
     (mu:type-of ((:lambda () (core:compile '(%defmacro a-macro () a-macro)) (core:%macro-function 'a-macro ()))))
     ((:lambda () (core:compile '(%defmacro no-arg-macro () ''no-arg-macro)) (core:%macroexpand '(no-arg-macro) ())))
     ((:lambda () (core:compile '(%defmacro no-arg-macro () ''no-arg-macro)) (mu:eval (core:compile '(no-arg-macro)))))
     ((:lambda () (core:compile '(%defmacro arg-macro (arg) arg)) (core:%macroexpand '(arg-macro (mu:add 1 2)) ())))
     ((:lambda () (core:compile '(%defmacro arg-macro (arg) arg)) (mu:eval (core:compile '(arg-macro (mu:add 1 2))))))
     ((:lambda () (core:compile '(%defmacro rest-macro (&rest args) (mu:cons '(lambda (&rest rest) rest) args))) (mu:eval (core:compile '(rest-macro (mu:add 1 2))))))
     ((:lambda () (core:compile '(%defmacro rest-macro (&rest args) (mu:cons '(lambda (&rest rest) rest) args))) (mu:eval (core:compile '(rest-macro (mu:add 1 2) (mu:add 3 4))))))
     ((:lambda () (core:compile '(%defmacro rest-macro (&rest args) (mu:cons '(lambda (&rest rest) rest) args))) (mu:eval (core:compile '(rest-macro 1 2 3)))))
     (mu:symbol-name (core:read (mu:open :string :input "a") () ()))
     (mu:symbol-name (core:read (mu:open :string :input "core:a") () ()))
     (core:read (mu:open :string :input "abcdefgh") () ())
     (core:read (mu:open :string :input "core:abcdefgh") () ())
     (core:read (mu:open :string :input "'abcdefgh") () ())
     (core:read (mu:open :string :input "'core:abcdefgh") () ())
     (core:read (mu:open :string :input "1024") () ())
     (core:read (mu:open :string :input "-1024") () ())
     (core:read (mu:open :string :input "1.024") () ())
     (core:read (mu:open :string :input "#b10101100") () ())
     (core:read (mu:open :string :input "#d1024") () ())
     (core:read (mu:open :string :input "#xabcdef") () ())
     (core:read (mu:open :string :input "(())") () ())
     (core:read (mu:open :string :input "(a b)") () ())
     (core:read (mu:open :string :input "(:a :b)") () ())
     (core:read (mu:open :string :input "(:abc ())") () ())
     (core:read (mu:open :string :input "(1 . 2)") () ())
     (core:read (mu:open :string :input "(1 2 . 3)") () ())
     (core:read (mu:open :string :input "((1 2) . 3)") () ())
     (core:read (mu:open :string :input "((1 2) . (3 4q))") () ())
     (core:stringp "abc")
     (core:typep '(1 2) :cons)
     (core:typep 1 :fixnum)
     (core:typep (mu:make-struct :struct ()) :struct)
     (core:typep "abc" :vector)
     (core:typep #(:t 1 2 3) :vector)
     (core:typep mu:*standard-input* :stream)
     (core:typep #\a :char)
     (core:typep 1.024e23 :float)
     (core:typep :foo :keyword)
     (core:typep 'foo :symbol)
     (core:typep () :null)
     (core:typep () 'symbol)
     (core:typep () '(satisfies core:null))
     (core:typep 1 '(satisfies core:%fixnump))
     (core:typep 1024e23 '(satisfies core:%floatp))
     (core:typep '(1 2 3) '(satisfies core:%consp))
     (core:typep #(:t 1 2 3) '(satisfies core:vectorp))
     (core:typep #\a '(satisfies core:%charp))
     (core:typep () '(not symbol))
     (core:typep () '(and))
     (core:typep () '(and (satisfies core:null)))
     (core:typep () '(and :null (satisfies core:null)))
     (core:typep () '(or))
     (core:typep () '(or (satisfies core:null)))
     (core:typep () '(or :null (satisfies core:null)))
     (core:make-vector '(1 2 3))
     (core:%core-type-p (core:make-vector '(1 2 3)))
     (core:vector-slice (core:make-vector '(1 2 3)) 1 2)
     (core:vector-length (core:make-vector '(1 2 3)))
     (core:vector-ref (core:make-vector '(1 2 3)) 1)
     (core:vectorp (core:make-vector '(1 2 3)))
     (core:vectorp (mu:make-vector :t '(1 2 3)))
     (core:vector-ref (core:vector-slice (core:make-vector '(1 2 3)) 1 2) 0)
     ()))
