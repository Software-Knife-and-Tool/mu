*version* constant mu:string
%char-macro-ns% constant mu:namespace
%macro-ns% constant mu:namespace
%symbol-macro-ns% constant mu:namespace
%types-ns% constant mu:namespace
;;; predicates
not mu:function (value:mu:T) mu:boolean
atom mu:function (value:mu:T) mu:boolean
constantp mu:function (value:mu:T) mu:boolean
numberp mu:function (n:mu:fixnum|mu:float) mu:boolean
zerop mu:function (n:mu:fixnum|mu:float) mu:boolean
minusp mu:function (n)))
plusp mu:function (n)))
charp mu:function (t) (mu:eq :char (mu:type-of t))))
consp mu:function (t) (mu:eq :cons (mu:type-of t))))
fixnump mu:function (t) (mu:eq :fixnum (mu:type-of t))))
floatp mu:function (t) (mu:eq :float (mu:type-of t))))
listp mu:function (t) (:if (core:consp t) :t (core:null t))))
namespacep mu:function (t) (mu:eq (core:type-of t) 'namespace)))
null mu:function (t) (mu:eq () t)))
streamp mu:function (t) (mu:eq :stream (mu:type-of t))))
structp mu:function (t) (mu:eq :struct (mu:type-of t))))
;;; syntactic sugar
%orf mu:function (arg arg1)))
%andf mu:function (arg arg1)))
;;; compiler
%compile-lambda mu:function (form env)))
%compile-defmacro mu:function (form env)))
%if mu:function (testf t-thunk f-thunk)))
%compile-if mu:function (form env)))
%compile-quasi mu:function (form env)))
%compile mu:function (form env)))
compile mu:function (form)))
;;; environment
environmentp mu:function (env)))
%make-env mu:function ()))
%env-prop mu:function (prop env)))
make-environment mu:function (bindings)))
%get-env mu:function (env symbol)))
%add-env mu:function (env symbol value)))
;;; strings
stringp mu:function (string)))
get-output-stream-string mu:function (stream)))
schar mu:function (str index)))
string= mu:function (str-1 str-2)))
%string-write mu:function (string escape stream)))
string-position mu:function (ch str)))
string-find mu:function (ch str)))
string mu:function (designator)))
string-append mu:function (list)))
substr mu:function (str start end)))
%read-string% (mu:open :string :bidir ))
read-string mu:function (str eof-error eof-value)))
write-string mu:function (str designator)))
write-line mu:function (str designator)))
;;; core types
%core-type-p mu:function (value)))
define-type mu:function (name properties)))
%type-predicate-map%)
%type-predicate mu:function (type value)))
%make-type mu:function (name property-values)))
%type-ref mu:function (prop-name struct)))
type-of mu:function (value)))
%typespec-map%)
%compound-typespec-map%)
typep mu:function (value typespec)))
;;; exceptions
%exceptionf mu:function (stream format-string printenv exception)))
with-exception mu:function (handler thunk)))
make-exception mu:function (cond value source reason env)))
error mu:function (value format-string arg-list)))
raise mu:function (value source reason)))
raise-env mu:function (value source reason)))
debug mu:function (value message)))
eprint mu:function (value message))
warn mu:function (value message)))
exceptionp mu:function (ex)))
(core:define-type %except)
%exception-prop mu:function (prop exception)))
;;; fixnum
1+ mu:function (n)))
1- mu:function (n)))
truncate mu:function (n m)))
floor mu:function (n m)))
ceiling mu:function (n m)))
mod mu:function (n m)))
rem mu:function (n m)))
round mu:function (n m)))
;;; format
%fmt-tilde mu:function (dest arg-list)))
%fmt-tab mu:function (dest arg-list)))
%fmt-percent mu:function (dest arg-list)))
%fmt-bang mu:function (dest arg-list)))
%fmt-decimal mu:function (dest arg-list)))
%fmt-hex mu:function (dest arg-list)))
%fmt-aesthetic mu:function (dest arg-list)))
%fmt-standard mu:function (dest arg-list)))
%fmt-op mu:function (dir dest arg-list)))
%fmt-loop mu:function (stream dest fmt arg-list)))
format mu:function (stream format-string arg-list)))
;;; compiled funcalls
%arg-list mu:function (arg-list)))
%lambda-arg-list mu:function (function arg-list)))
%quoted-lambda-arg-list mu:function (fn args)))
%compile-arg-list mu:function (arg-list env)))
%compile-lambda-arg-list mu:function (function arg-list env)))
%compile-quoted-lambda-arg-list mu:function (function arg-list env)))
%compile-lambda-call mu:function (lambda-form arg-list env)))
%compile-symbol-call mu:function (function-symbol arg-list env)))
%compile-funcall mu:function (function-form arg-list env)))
%fn-apply mu:function (fn arg-list)))
%fn-apply-quoted mu:function (fn arg-list)))
;;; function
apply mu:function (function arg-list)))
(core:define-type %fn)
%fn-prop mu:function (prop fn)))
%core-function-p mu:function (fn)))
functionp mu:function (fn)))
%describe-fn mu:function (fn)))
%make-fn mu:function (lambda fn env)))
%closure-env mu:function (lambda body env)))
%compile-function mu:function (form env)))
;;; lambdas
%lambdap mu:function (fn)))
(core:define-type %lambda)
%lambda-prop mu:function (prop lambda)))
%apply-lambda mu:function (fn) (fn)))
%make-lambda mu:function (lambda-list rest-sym env)))
%compile-lambda-desc mu:function (lambda env)))
%compile-lambda-body mu:function (lambda-desc body env)))
%frame-ref mu:function (symbol env)))
;;; lsts
dotted-pair-p mu:function (list)))
findl mu:function (function list)))
findr mu:function (function list)))
positionl mu:function (function list)))
positionr mu:function (function list)))
append mu:function (list)))
reverse mu:function (list)))
dropl mu:function (list n)))
dropr mu:function (list n)))
last mu:function (list)))
count mu:function (item list)))
;;; macros
%defmacro mu:function (symbol macro-function)))
%compile-macro-call mu:function (macro-symbol arg-list env)))
macroexpand-1 mu:function (form env)))
macroexpand mu:function (form env)))
macro-function mu:function (symbol env)))
;;; maps
%foldl mu:function (function init list)))
foldl mu:function (function init list)))
foldr mu:function (function init list)))
%mapc mu:function (function list)))
mapc mu:function (function list)))
%mapcar mu:function (function list)))
mapcar mu:function (function list)))
mapl mu:function (function list)))
maplist mu:function (function list)))
%assq mu:function (item alist)))
assq mu:function (item alist)))
%rassq mu:function (item alist)))
rassq mu:function (item alist)))
;;; namespaces
(core:define-type %ns)
%namespace-prop mu:function (prop namespace)))
%make-namespace mu:function (name uses)))
make-namespace mu:function (name uses)))
intern mu:function (symbol value)))
%gen-anon-ns mu:function ()))
;;; parsers
parse-integer mu:function (digits base)))
parse-float mu:function (str)))
;;; quasiquote
(mu:intern (mu:find-namespace ) %quasi% ())
%list mu:function (form)))
%quasi-func-map mu:function (key map)))
%quasi-read mu:function (stream)))
%quasi-read-list mu:function (stream)))
%quasi-compile mu:function (quasi-expr)))
%read-quasi mu:function (char stream)))
;;; reader
%eof% (mu:make-symbol eof))
%reader-stream% (mu:open :string :output ))
%reader-current-ns% (mu:open :string :bidir core))
%in-namespace mu:function (ns)))
%reader-get-ns mu:function ()))
%reader-set-ns mu:function (ns)))
%read-char-syntax mu:function (ch)))
%read-number mu:function (atom)))
%read-atom mu:function (ch stream)))
%read-dispatch mu:function (ch stream)))
%read-consume-ws mu:function (stream)))
%read mu:function (stream)))
%read-sharp-char mu:function (ch stream)))
%read-sharp-comment mu:function (ch stream)))
%read-sharp-vector mu:function (ch stream)))
%read-byte-bits mu:function (stream)))
%read-sharp-bit-vector mu:function (ch stream)))
%read-sharp-dot mu:function (ch stream)))
%read-sharp-colon mu:function (ch stream)))
%read-sharp-number mu:function (base stream)))
%read-sharp mu:function (ch stream)))
%read-list-eol% (mu:make-symbol eol))
%read-list-eol mu:function (ch stream)))
%read-list mu:function (ch stream)))
%read-string mu:function (ch stream)))
%read-quote mu:function (ch stream)))
%read-line-comment mu:function (ch stream)))
%read-macro mu:function (ch stream)))
;;; reader macros
get-macro-character mu:function (char)))
set-macro-character mu:function (char fn non-terminating)))
;;; streams
%write-stream-designator mu:function (designator)))
%read-stream-designator mu:function (designator)))
make-string-stream mu:function (dir init)))
open mu:function (dir path)))
close mu:function (stream)))
with-open-file mu:function (type dir specifier fn)))
load-file mu:function (path)))
write-char mu:function (ch designator)))
write-byte mu:function (byte designator)))
read-char mu:function (designator error-eofp eof-value)))
read-byte mu:function (designator error-eofp eof-value)))
peek-char mu:function (designator error-eofp eof-value)))
unread-char mu:function (ch designator)))
read mu:function (designator eof-error eof-value)))
read-line mu:function (stream eof-error-p eof-value)))
write mu:function (object escape designator)))
;;; symbols
boundp mu:boundp)
fboundp mu:function (symbol)))
uninternedp mu:function (sym)))
keywordp mu:function (t)))
symbolp mu:function (t)))
symbol-name mu:symbol-name)
symbol-namespace mu:function (sym)))
symbol-value mu:symbol-value)
make-keyword mu:function (name)))
%gensym-counter)
gensym mu:function ()))
genkeyword mu:function (prefix)))
%read-keywordp mu:function (name)))
%read-symbol-scope mu:function (name)))
%read-symbol-ns mu:function (name)))
%read-symbol-name mu:function (name)))
%read-symbol mu:function (symbol)))
%symbol-macro-expand mu:function (symbol)))
%get-symbol-macro mu:function (symbol)))
define-symbol-macro mu:function (symbol form)))
;;; (core:define-symbol-macro 't :t)
;;; (core:define-symbol-macro 'nil :nil)
%typespec-map%)
%compound-typespec-map%)
typep mu:function (value typespec)))
(core:define-type %vector)
%vector-prop mu:function (prop vector)))
%make-vector mu:function (vector displace bitvec)))
vectorp mu:function (vector)))
bit-vector-p mu:function (vector)))
vector-displaced-p mu:function (vector)))
make-vector mu:function (list)))
vector-slice mu:function (vector start length)))
vector-length mu:function (vector)))
vector-type mu:function (vector)))
vector-ref mu:function (vector nth)))
%vector-write mu:function (vector escape stream)))
%specialized-vector-type mu:function (list)))
%map-vector mu:function (fn vector)))
